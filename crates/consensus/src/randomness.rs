//! # Randomness Beacon
//!
//! This module implements a VRF-based randomness beacon for the Proto Core blockchain.
//! It provides unpredictable, verifiable on-chain randomness using Verifiable Random Functions.
//!
//! ## Overview
//!
//! Block proposers generate VRF proofs that can be verified by anyone. The VRF output
//! provides the block's randomness, and epoch randomness is accumulated from all block
//! contributions within an epoch.
//!
//! ## Usage
//!
//! ```rust,ignore
//! use protocore_consensus::randomness::{RandomnessBeacon, BlockRandomness};
//! use protocore_crypto::vrf::VrfSecretKey;
//!
//! // Create a randomness beacon with genesis randomness
//! let genesis_randomness = [0u8; 32];
//! let mut beacon = RandomnessBeacon::new(genesis_randomness, 100);
//!
//! // Generate block randomness as proposer
//! let vrf_key = VrfSecretKey::from_seed(&[42u8; 32]);
//! let block_randomness = beacon.generate_block_randomness(
//!     &vrf_key,
//!     1,
//!     &[0u8; 32],
//! );
//!
//! // Verify and apply block randomness
//! beacon.verify_and_apply(
//!     1,
//!     &[0u8; 32],
//!     vrf_key.public_key(),
//!     &block_randomness,
//! ).expect("verification should succeed");
//! ```
//!
//! ## Epoch Transitions
//!
//! At the end of each epoch (determined by `blocks_per_epoch`), the beacon:
//! 1. Hashes all VRF contributions from the epoch
//! 2. Updates the epoch randomness
//! 3. Clears the contribution buffer
//!
//! This ensures that the randomness for each epoch depends on contributions from
//! all block proposers, making it unpredictable until the epoch is complete.

use protocore_crypto::vrf::{VrfOutput, VrfProof, VrfPublicKey, VrfSecretKey};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use thiserror::Error;

/// Randomness beacon state
///
/// Maintains the current and previous epoch randomness, along with
/// accumulated VRF contributions for the current epoch.
#[derive(Clone)]
pub struct RandomnessBeacon {
    /// Current epoch randomness
    current_randomness: [u8; 32],
    /// Previous epoch randomness (for lookback queries)
    previous_randomness: [u8; 32],
    /// Accumulated VRF outputs this epoch
    epoch_contributions: Vec<VrfOutput>,
    /// Current epoch number
    epoch: u64,
    /// Blocks per epoch
    blocks_per_epoch: u64,
    /// Current block height within the epoch
    current_height: u64,
}

/// Block randomness data included in each block
///
/// Contains the VRF proof generated by the block proposer and the
/// resulting random value derived from it.
#[derive(Clone, Debug, Serialize, Deserialize, Default)]
pub struct BlockRandomness {
    /// VRF proof from proposer
    pub vrf_proof: VrfProof,
    /// Resulting random value (first 32 bytes of VRF output)
    pub random_value: [u8; 32],
    /// Input used for VRF (epoch_randomness || block_height || parent_hash)
    pub vrf_input: [u8; 32],
}

/// Errors that can occur during randomness operations
#[derive(Debug, Error)]
pub enum RandomnessError {
    /// VRF proof verification failed
    #[error("invalid VRF proof")]
    InvalidVrfProof,

    /// Random value doesn't match VRF output
    #[error("randomness mismatch: computed value doesn't match claimed value")]
    RandomnessMismatch,

    /// Block height doesn't match expected
    #[error("epoch mismatch: block height {0} doesn't match beacon state")]
    EpochMismatch(u64),

    /// Invalid block height
    #[error("invalid block height: expected {expected}, got {actual}")]
    InvalidBlockHeight { expected: u64, actual: u64 },
}

impl RandomnessBeacon {
    /// Create a new randomness beacon
    ///
    /// # Arguments
    ///
    /// * `genesis_randomness` - Initial randomness for epoch 0
    /// * `blocks_per_epoch` - Number of blocks in each epoch
    pub fn new(genesis_randomness: [u8; 32], blocks_per_epoch: u64) -> Self {
        Self {
            current_randomness: genesis_randomness,
            previous_randomness: [0u8; 32],
            epoch_contributions: Vec::with_capacity(blocks_per_epoch as usize),
            epoch: 0,
            blocks_per_epoch,
            current_height: 0,
        }
    }

    /// Generate randomness for a new block
    ///
    /// This should be called by the block proposer to generate the VRF proof
    /// and random value for inclusion in their block.
    ///
    /// # Arguments
    ///
    /// * `proposer_vrf_key` - The proposer's VRF secret key
    /// * `block_height` - The height of the block being proposed
    /// * `parent_hash` - The hash of the parent block
    ///
    /// # Returns
    ///
    /// A `BlockRandomness` struct containing the VRF proof and random value
    pub fn generate_block_randomness(
        &self,
        proposer_vrf_key: &VrfSecretKey,
        block_height: u64,
        parent_hash: &[u8; 32],
    ) -> BlockRandomness {
        // VRF input = epoch_randomness || block_height || parent_hash
        let input = self.compute_vrf_input(block_height, parent_hash);

        let (output, proof) = proposer_vrf_key.prove(&input);

        // Block randomness is first 32 bytes of VRF output
        let mut random_value = [0u8; 32];
        random_value.copy_from_slice(&output.value[..32]);

        // Store first 32 bytes of input for reference
        let mut vrf_input = [0u8; 32];
        vrf_input.copy_from_slice(&input[..32]);

        BlockRandomness {
            vrf_proof: proof,
            random_value,
            vrf_input,
        }
    }

    /// Verify and apply block randomness
    ///
    /// This should be called when validating a block to verify the VRF proof
    /// and update the beacon state with the new contribution.
    ///
    /// # Arguments
    ///
    /// * `block_height` - The height of the block
    /// * `parent_hash` - The hash of the parent block
    /// * `proposer_vrf_pubkey` - The proposer's VRF public key
    /// * `block_randomness` - The randomness data from the block
    ///
    /// # Returns
    ///
    /// `Ok(())` if verification succeeds, or an error describing the failure
    pub fn verify_and_apply(
        &mut self,
        block_height: u64,
        parent_hash: &[u8; 32],
        proposer_vrf_pubkey: &VrfPublicKey,
        block_randomness: &BlockRandomness,
    ) -> Result<(), RandomnessError> {
        // Reconstruct input
        let input = self.compute_vrf_input(block_height, parent_hash);

        // Verify VRF proof
        let output = proposer_vrf_pubkey
            .verify(&input, &block_randomness.vrf_proof)
            .ok_or(RandomnessError::InvalidVrfProof)?;

        // Verify random value matches
        if output.value[..32] != block_randomness.random_value[..] {
            return Err(RandomnessError::RandomnessMismatch);
        }

        // Accumulate for epoch transition
        self.epoch_contributions.push(output);
        self.current_height = block_height;

        // Check for epoch transition
        if block_height > 0 && block_height % self.blocks_per_epoch == 0 {
            self.transition_epoch();
        }

        Ok(())
    }

    /// Apply block randomness without verification
    ///
    /// This is useful when replaying blocks that have already been verified,
    /// such as during state sync or chain replay.
    ///
    /// # Safety
    ///
    /// Only call this if you are certain the block randomness has already
    /// been verified.
    pub fn apply_without_verification(
        &mut self,
        block_height: u64,
        block_randomness: &BlockRandomness,
    ) {
        // Create output from the random value
        let mut output = VrfOutput::default();
        output.value[..32].copy_from_slice(&block_randomness.random_value);

        self.epoch_contributions.push(output);
        self.current_height = block_height;

        // Check for epoch transition
        if block_height > 0 && block_height % self.blocks_per_epoch == 0 {
            self.transition_epoch();
        }
    }

    /// Compute the VRF input for a given block
    fn compute_vrf_input(&self, block_height: u64, parent_hash: &[u8; 32]) -> Vec<u8> {
        let mut input = Vec::with_capacity(72);
        input.extend_from_slice(&self.current_randomness);
        input.extend_from_slice(&block_height.to_le_bytes());
        input.extend_from_slice(parent_hash);
        input
    }

    /// Transition to a new epoch, computing new randomness
    ///
    /// The new epoch randomness is the hash of:
    /// - Domain separator "EPOCH_RANDOMNESS"
    /// - The epoch number
    /// - All VRF contributions from the epoch
    fn transition_epoch(&mut self) {
        self.previous_randomness = self.current_randomness;

        // New randomness = hash of all contributions
        let mut hasher = Sha256::new();
        hasher.update(b"EPOCH_RANDOMNESS");
        hasher.update(self.epoch.to_le_bytes());
        for contribution in &self.epoch_contributions {
            hasher.update(contribution.value);
        }
        self.current_randomness = hasher.finalize().into();

        self.epoch += 1;
        self.epoch_contributions.clear();

        tracing::info!(
            epoch = self.epoch,
            randomness = hex::encode(self.current_randomness),
            "epoch transition: new randomness computed"
        );
    }

    /// Get current verifiable randomness
    pub fn current(&self) -> &[u8; 32] {
        &self.current_randomness
    }

    /// Get the current epoch number
    pub fn epoch(&self) -> u64 {
        self.epoch
    }

    /// Get randomness for a specific epoch
    ///
    /// Only the current and immediately previous epoch are available.
    /// For older epochs, query the historical state.
    pub fn for_epoch(&self, epoch: u64) -> Option<[u8; 32]> {
        if epoch == self.epoch {
            Some(self.current_randomness)
        } else if epoch == self.epoch.saturating_sub(1) && self.epoch > 0 {
            Some(self.previous_randomness)
        } else {
            None // Would need to query historical state
        }
    }

    /// Get the number of blocks per epoch
    pub fn blocks_per_epoch(&self) -> u64 {
        self.blocks_per_epoch
    }

    /// Get the number of contributions accumulated in the current epoch
    pub fn epoch_contribution_count(&self) -> usize {
        self.epoch_contributions.len()
    }

    /// Get the current block height tracked by the beacon
    pub fn current_height(&self) -> u64 {
        self.current_height
    }

    /// Reset the beacon to a specific state
    ///
    /// This is useful for chain reorganizations or testing.
    pub fn reset(&mut self, randomness: [u8; 32], epoch: u64, height: u64) {
        self.current_randomness = randomness;
        self.previous_randomness = [0u8; 32];
        self.epoch = epoch;
        self.current_height = height;
        self.epoch_contributions.clear();
    }

    /// Create a snapshot of the beacon state
    pub fn snapshot(&self) -> RandomnessBeaconSnapshot {
        RandomnessBeaconSnapshot {
            current_randomness: self.current_randomness,
            previous_randomness: self.previous_randomness,
            epoch: self.epoch,
            blocks_per_epoch: self.blocks_per_epoch,
            current_height: self.current_height,
            contribution_count: self.epoch_contributions.len() as u64,
        }
    }

    /// Restore from a snapshot
    ///
    /// Note: This does not restore the individual contributions, only the
    /// aggregate state. This is suitable for state sync scenarios where
    /// you're restoring at an epoch boundary.
    pub fn restore_from_snapshot(snapshot: RandomnessBeaconSnapshot) -> Self {
        Self {
            current_randomness: snapshot.current_randomness,
            previous_randomness: snapshot.previous_randomness,
            epoch_contributions: Vec::with_capacity(snapshot.blocks_per_epoch as usize),
            epoch: snapshot.epoch,
            blocks_per_epoch: snapshot.blocks_per_epoch,
            current_height: snapshot.current_height,
        }
    }
}

/// Snapshot of randomness beacon state for persistence
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct RandomnessBeaconSnapshot {
    /// Current epoch randomness
    pub current_randomness: [u8; 32],
    /// Previous epoch randomness
    pub previous_randomness: [u8; 32],
    /// Current epoch number
    pub epoch: u64,
    /// Blocks per epoch configuration
    pub blocks_per_epoch: u64,
    /// Current block height
    pub current_height: u64,
    /// Number of contributions in current epoch
    pub contribution_count: u64,
}
